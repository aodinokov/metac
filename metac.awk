#!/usr/bin/gawk -f

function mark_obj(id) {
    if ("marked" in data[id])
        return;
    data[id]["marked"] = 1;
    if ("child" in data[id])
        for (c in data[id]["child"])
            mark_obj(data[id]["child"][c]);
    if ("DW_AT_type" in data[id]) {
        match(data[id]["DW_AT_type"], /<([^>]+)>/, ref_type_data);
        mark_obj(ref_type_data[1]);
    }
}

function dump_at(data_id, at_id) {
    res = 0;
    if (match(at_id, "DW_AT_(.*)", arr0)) {
        switch(at_id){
        case "DW_AT_name":
            #print "\t{id: " at_id ", name: \"" data[data_id][at_id] "\"},";
            print "\t{.id = " at_id ", ." arr0[1] " = \"" data[data_id][at_id] "\"},";
            ++res;
            break;
        case "DW_AT_data_member_location":
            if (match(data[data_id][at_id], "([0-9]+).*", arr)) {
                #print "\t{id: " at_id ", data_member_location: " arr[1] "/*" data[data_id][at_id] "*/},";
                print "\t{.id = " at_id ", ." arr0[1] " = " arr[1] "/*" data[data_id][at_id] "*/},";
                ++res;
            }
            break;
        case "DW_AT_type":
            if (match(data[data_id][at_id], "<([^>]+)>", arr)) {
                #print "\t{id: " at_id ", type: &data_" arr[1] "},";
                print "\t{.id = " at_id ", ." arr0[1] " = &data_" arr[1] "},";
                ++res;
            }
            break;
        case "DW_AT_byte_size":
        case "DW_AT_bit_offset":
        case "DW_AT_bit_size":
        case "DW_AT_encoding":
        case "DW_AT_lower_bound":
        case "DW_AT_upper_bound":
        case "DW_AT_const_value":
                #print "\t{id: " at_id ", " arr0[1] ": " data[data_id][at_id] "},"
                print "\t{.id = " at_id ", ." arr0[1] " = " data[data_id][at_id] "},"
            ++res;
            break;
        default:
                #print "\t/* Skip {id: " at_id ", " arr0[1] ": " data[data_id][at_id] "}, */"
                print "\t/* Skip {.id = " at_id ", ." arr0[1] " = " data[data_id][at_id] "}, */"
        }
    }
    return res;
}

function at_name_is_in_task(name) {
    if (name in task)
        return 1;
    if (name == "long int")
        return ("long" in task);
    if (name == "short int")
        return ("short" in task);
    return 0;
}

function export_name(name) {
    if (name == "long int")
        return "long";
    if (name == "short int")
        return "short";
    return name;
}

BEGIN {
    obj_stack[0] = ""
    if (file) {
        file;
        while(( getline line < file ) > 0 ) {
            split(line, x, " ");
            task[x[2]] = x[1];
        }
    }else{
        task[0] = "";
        delete task[0];
    }
}

END {
    for (i in data) {
        if ( length(task) == 0 ||
            ("DW_AT_name" in data[i] && at_name_is_in_task(data[i]["DW_AT_name"])))
            mark_obj(i);
    }
    asort(obj);
    for (i in data) {
        if (data[i]["marked"] == 1) {
            obj[length(obj)] = i;
        }
    }
    asort(obj);
    print "/* This file is autogenerated. Don't modify it if you aren't really sure about the reason. */";
    print "#include \"metac_type.h\""
    print "\n/* early declaration */"
    for (i in obj) {
        print "static struct metac_type data_" obj[i] ";";
    }
    print "\n/* real data */"
    for (i in obj) {
        in_task = 0;
        i = obj[i];
        p_at = "";
        print "/* --" i "--*/"
        if ("child" in data[i]) {
            print "static struct metac_type *data_" i "_child[] = {";
            for (k in data[i]["child"]) print "\t&data_" data[i]["child"][k] ",";
            print "};"
        }
        at_num = 0;
        print "static struct metac_type_at data_" i "_at[] = {";
        for (j in data[i]) {
            if (match(j, "DW_AT_(.*)", arr0)) {
                dump_res = dump_at(i, j);
                if (dump_res > 0)
                    p_at= p_at "\t\t.at_" arr0[1] " = &data_" i "_at[" at_num "],\n" 
                at_num += dump_res;
                if (j == "DW_AT_name" && at_name_is_in_task(data[i][j]))
                    in_task = 1;
            }
        }
        print "};"

        print "static struct metac_type data_" i " = {";
        if ("type" in data[i]) {
            #print "\ttype: " data[i]["type"] ","
            print "\t.id = " data[i]["type"] ","
        }
        if ("child" in data[i]) {
            #print "\tchild_num: " length(data[i]["child"]) ","
            #print "\tchild: data_" i "_child,";
            print "\t.child_num = " length(data[i]["child"]) ","
            print "\t.child = data_" i "_child,";
        } else {
            #print "\tchild_num: 0,";
            #print "\t.child_num = 0,";
        }

        #print "\tat_num: " at_num ",";
        print "\t.at_num = " at_num ",";
        #if (at_num > 0) {
            #print "\tat: data_" i "_at,";
            print "\t.at = data_" i "_at,";
        #}
        
        print "\t.p_at = {\n" p_at "\t},";
        print "};"
        if (in_task != 0) {
            print "struct metac_type *metac__type_" export_name(data[i]["DW_AT_name"]) " = &data_" i ";";
            delete task[export_name(data[i]["DW_AT_name"])];
        }
        print;
    }
}
/^<[^>]+><[^>]+>/{
    while (match($0, /<([^>]+)><([^>]+)>[ \t]+([^ \t]*)/, arr)) {
        inx = arr[2];
        val = arr[3];
        data[inx]["type"] = val;
        #print $0 > "/dev/stderr";
        #print length(obj_stack) > "/dev/stderr";
        # maintain object tree
        if (length(obj_stack) == (arr[1] + 1)) {
            obj_stack[length(obj_stack) - 1] = inx;
        } else if (length(obj_stack) < (arr[1] + 1)) {
            #print "stack.push" > "/dev/stderr";
            if (length(obj_stack) != arr[1]) print "ASSERT: " length(obj_stack) "!=" arr[1] > "/dev/stderr";
            obj_stack[length(obj_stack)] = inx;
        } else while(length(obj_stack) > (arr[1] + 1)) {
            #print "stack.pop" > "/dev/stderr";
            delete obj_stack[length(obj_stack) - 1];
            obj_stack[length(obj_stack) - 1] = inx;
        }

        # mark the current obj as a child in the parent
        if (length(obj_stack) > 1)
            data[obj_stack[length(obj_stack) - 2]]["child"][length(data[obj_stack[length(obj_stack) - 2]]["child"])] = inx;

        while ( getline line > 0 && 
            match(line, "^[ \\t]{" index($0, val) ",}([^ \t]+)[ \t]+\"{0,1}([^\"]*)\"{0,1}", arr2)) {
            #print "             ", arr2[1], arr2[2];
            data[inx][arr2[1]]=arr2[2];
        }
        $0 = line;
    }
}
