#!/usr/bin/gawk -f

function mark_obj(id) {
    if ("marked" in data[id])
        return;
    data[id]["marked"] = 1;
    if ("child" in data[id])
        for (c in data[id]["child"])
            mark_obj(data[id]["child"][c]);
    if ("DW_AT_type" in data[id]) {
        match(data[id]["DW_AT_type"], /<([^>]+)>/, ref_type_data);
        mark_obj(ref_type_data[1]);
    }
}

function dump_at(data_id, at_id) {
    res = 0;
    if (match(at_id, "DW_AT_(.*)", arr0)) {
        switch(at_id){
        case "DW_AT_name":
            #print "\t{id: " at_id ", name: \"" data[data_id][at_id] "\"},";
            print "\t{.id = " at_id ", ." arr0[1] " = \"" data[data_id][at_id] "\"},";
            ++res;
            break;
        case "DW_AT_data_member_location":
            if (match(data[data_id][at_id], "([0-9]+).*", arr)) {
                #print "\t{id: " at_id ", data_member_location: " arr[1] "/*" data[data_id][at_id] "*/},";
                print "\t{.id = " at_id ", ." arr0[1] " = " arr[1] "/*" data[data_id][at_id] "*/},";
                ++res;
            }
            break;
        case "DW_AT_type":
            if (match(data[data_id][at_id], "<([^>]+)>", arr)) {
                #print "\t{id: " at_id ", type: &data_" arr[1] "},";
                print "\t{.id = " at_id ", ." arr0[1] " = &" export_type_name(arr[1]) "},";
                ++res;
            }
            break;
        case "DW_AT_byte_size":
        case "DW_AT_bit_offset":
        case "DW_AT_bit_size":
        case "DW_AT_encoding":
        case "DW_AT_lower_bound":
        case "DW_AT_upper_bound":
        case "DW_AT_const_value":
                #print "\t{id: " at_id ", " arr0[1] ": " data[data_id][at_id] "},"
                print "\t{.id = " at_id ", ." arr0[1] " = " data[data_id][at_id] "},"
            ++res;
            break;
        default:
                #print "\t/* Skip {id: " at_id ", " arr0[1] ": " data[data_id][at_id] "}, */"
                print "\t/* Skip {.id = " at_id ", ." arr0[1] " = " data[data_id][at_id] "}, */"
        }
    }
    return res;
}

function export_name(name) {
    if (name == "long int")
        return "long";
    if (name == "short int")
        return "short";
    return name;
}

function export_name_in_task4types(name) {
    if (export_name(name) in task4types)
        return 1;
    return 0;
}

function need_static(addr) {
    if (("DW_AT_name" in data[addr]) &&
        export_name_in_task4types(data[addr]["DW_AT_name"]))
            return "";
    return "static ";
}

function export_type_name(addr) {
    type = data[addr]["type"]
    if (!("DW_AT_name" in data[addr]) ||
        type == "DW_TAG_member" ||
        type == "DW_TAG_enumerator" ||
        type == "DW_TAG_formal_parameter")
        return "data_" addr;
    
    name = export_name(data[addr]["DW_AT_name"]);
    
    if (!(name in task4types) &&
        !(name in types_array))
        return "data_" addr;
    
    return "metac__type_" gensub(/ /, "_", "g", name);
}

# workaround for old clang: https://travis-ci.org/aodinokov/metac/jobs/194107462
function definintion_of_export_type_name(addr) {
    if (("DW_AT_name" in data[addr]) &&
        export_name_in_task4types(data[addr]["DW_AT_name"]))
            return export_type_name(addr);
    return "data_" addr;
}

BEGIN {
    obj_stack[0] = ""
    if (file) {
        file;
        while(( getline line < file ) > 0 ) {
            split(line, x, " ");
            switch (x[1]) {
            case "type":
                task4types[x[2]] = x[1];
                break;
            case "object":
                task4objects[x[2]] = x[1];
                break;
            case "types":
                # we ignore them
                break;
            case "objects":
                # we ignore them
                break;
            default:
                print "WARNING: Unknown task type for line: " line > "/dev/stderr";
                break;
            }
        }
    }else{
        task4types[0] = "";
        delete task4types[0];
        task4objects[0] = "";
        delete task4objects[0];
    }
}

END {
    for (i in data) {
        if ( length(task4types) == 0 ||
            ("DW_AT_name" in data[i] && export_name_in_task4types(data[i]["DW_AT_name"])))
            mark_obj(i);
    }
    asort(obj);
    for (i in data) {
        if (data[i]["marked"] == 1) {
            obj[length(obj)] = i;
        }
    }
    asort(obj);
    print "/* This file is autogenerated. Don't modify it if you aren't really sure about the reason. */";
    print "#include \"metac_type.h\""
    print "#include <stdio.h>  /* NULL */"
    print "\n/* early declaration */"
    for (i in obj) {
        i = obj[i];
        print need_static(i) "struct metac_type " export_type_name(i) "; /* " i " */";
    }
    print "\n/* real data */"
    
    types_array[0] = "";
    delete types_array[0];
    
    for (i in obj) {
        in_task4types = 0;
        i = obj[i];
        p_at = "";
        print "/* --" i "--*/"
        if ("child" in data[i]) {
            print "static struct metac_type *data_" i "_child[] = {";
            for (k in data[i]["child"]) print "\t&" export_type_name(data[i]["child"][k]) ",";
            print "};"d
        }
        at_num = 0;
        print "static struct metac_type_at data_" i "_at[] = {";
        for (j in data[i]) {
            if (match(j, "DW_AT_(.*)", arr0)) {
                dump_res = dump_at(i, j);
                if (dump_res > 0)
                    p_at= p_at "\t\t.p_at_" arr0[1] " = &data_" i "_at[" at_num "],\n" 
                at_num += dump_res;
                if (j == "DW_AT_name" && export_name_in_task4types(data[i][j]))
                    in_task4types = 1;
            }
        }
        print "};"

        print need_static(i) "struct metac_type " definintion_of_export_type_name(i) " = {";
        if ("type" in data[i]) {
            #print "\ttype: " data[i]["type"] ","
            print "\t.id = " data[i]["type"] ","
        }
        if ("child" in data[i]) {
            #print "\tchild_num: " length(data[i]["child"]) ","
            #print "\tchild: data_" i "_child,";
            print "\t.child_num = " length(data[i]["child"]) ","
            print "\t.child = data_" i "_child,";
        } else {
            #print "\tchild_num: 0,";
            #print "\t.child_num = 0,";
        }

        #print "\tat_num: " at_num ",";
        print "\t.at_num = " at_num ",";
        #if (at_num > 0) {
            #print "\tat: data_" i "_at,";
            print "\t.at = data_" i "_at,";
        #}
        
        print "\t.p_at = {\n" p_at "\t},";
        print "};"
        if (in_task4types != 0) {
            types_array[export_name(data[i]["DW_AT_name"])] = export_type_name(i);
            delete task4types[export_name(data[i]["DW_AT_name"])];
        }
        print;
    }
    #print all types
    print "struct metac_type_sorted_array METAC_TYPES_ARRAY = {"
    asorti(types_array, types_array_sorted);
    print "\t.number = " length(types_array_sorted) ",";
    print "\t.item = {";

    for (i in types_array_sorted) {
        print "\t\t{.name = \"" types_array_sorted[i] "\", .ptr = &" types_array[types_array_sorted[i]] "},"
    }

    print "\t},\n};\n";

    #print all objects
    for (i in task4objects) {
        print "extern struct metac_object METAC_OBJECT_NAME(" i ");"
    }
    print
    print "struct metac_object_sorted_array METAC_OBJECTS_ARRAY = {"
    asorti(task4objects, task4objects_sorted);

    print "\t.number = " length(task4objects_sorted) ",";
    print "\t.item = {";
    for (i in task4objects_sorted) {
        print "\t\t{.name = \"" task4objects_sorted[i] "\", .ptr = &METAC_OBJECT_NAME(" task4objects_sorted[i] ")},"
    }
    print "\t},\n};\n";
}
/^<[^>]+><[^>]+>/{
    while (match($0, /<([^>]+)><([^>]+)>[ \t]+([^ \t]*)/, arr)) {
        inx = arr[2];
        val = arr[3];
        data[inx]["type"] = val;
        #print $0 > "/dev/stderr";
        #print length(obj_stack) > "/dev/stderr";
        # maintain object tree
        if (length(obj_stack) == (arr[1] + 1)) {
            obj_stack[length(obj_stack) - 1] = inx;
        } else if (length(obj_stack) < (arr[1] + 1)) {
            #print "stack.push" > "/dev/stderr";
            if (length(obj_stack) != arr[1]) print "ASSERT: " length(obj_stack) "!=" arr[1] > "/dev/stderr";
            obj_stack[length(obj_stack)] = inx;
        } else while(length(obj_stack) > (arr[1] + 1)) {
            #print "stack.pop" > "/dev/stderr";
            delete obj_stack[length(obj_stack) - 1];
            obj_stack[length(obj_stack) - 1] = inx;
        }

        # mark the current obj as a child in the parent
        if (length(obj_stack) > 1)
            data[obj_stack[length(obj_stack) - 2]]["child"][length(data[obj_stack[length(obj_stack) - 2]]["child"])] = inx;

        while ( getline line > 0 && 
            match(line, "^[ \\t]{" index($0, val) ",}([^ \t]+)[ \t]+\"{0,1}([^\"]*)\"{0,1}", arr2)) {
            #print "             ", arr2[1], arr2[2];
            data[inx][arr2[1]]=arr2[2];
        }
        $0 = line;
    }
}
