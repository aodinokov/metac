#ifndef INCLUDE_METAC_REQRESP_H_
#define INCLUDE_METAC_REQRESP_H_

/** \page req_res Requests to code-generator and responses from it
 
 Metac could make all DWARF information available, but it's better to have ability to
 request some specific information. METAC_GSYM_LINK and METAC_DECLLOC are the good examples of those requests:
 metac template module will find such requests and will generate some specific information - response.

 We're using objects (e.g. variables) which have names build with special pattern: `metac__x_y`, where
 x is a request name and y is more specific information about that request. Obviously request names can't include underscore
 to be parsed properly by template module.

Here is one more problem - sometimes names of the requested objects may overlap.
It can be controlled within 1 library, but it is harder if there are many libraries written by different people.

Because of that issue we introduced the same request/response macroses, but which include also name of the module.
By default module name is set to dflt. But if application wants to use it's own, it has to have the line `METAC_MODULE(METAC_MODULE_NAME);`
in its code. (There is a potential way to make it better in future and don't require this).

The simplest example is how METAC_GSYM_LINK works. it defines the macroses:

```c
#define METAC_GSYM_LINK_NAME(name) METAC_MODULE_REQUEST(METAC_MODULE_NAME, gsym, name)
#define METAC_GSYM_NAME(name) METAC_MODULE_RESPONSE(METAC_MODULE_NAME, gsym, name)
```

it just defines the request/response type with name `gsym` for the current modulename, so all requests will start from `metac__dflt_gsym_`.

Link is a request and the response is external variable with almost the same name (one underscore is missed after metac).

```c
#ifndef _METAC_OFF_
#define _METAC_GSYM_LINK(name) \
    extern metac_entry_t *METAC_GSYM_NAME(name); \
    struct metac_entry_link METAC_GSYM_LINK_NAME(name) = {.pp_entry = &METAC_GSYM_NAME(name), .p_data = (void *)&(name)}
#else
#define _METAC_GSYM_LINK(name) \
    struct metac_entry_link METAC_GSYM_LINK_NAME(name) = {.pp_entry = NULL, .p_data = (void *)&(name)}
#endif
```

Since we compile twice and the first time is with `-D_METAC_OFF_` - only request will be produced, but it will be read,
response will be generated by template module and when we compile the second time without `-D_METAC_OFF_` it will be linked, so 
p_data will point to that response. Basically linker does for us all the work to match request and response.

*/

/* markers that are used to request global params. e.g. to inform about module name */
#define _METAC_REQUEST(x, name) metac__ ## x ## _ ## name
#define METAC_REQUEST(x, name) _METAC_REQUEST(x, name)
#define _METAC_RESPONSE(x, name) metac_ ## x ## _ ## name
#define METAC_RESPONSE(x, name) _METAC_RESPONSE(x, name)

/* markers that are used to request module specific params this should be a majority */
#define _METAC_MODULE_REQUEST(m, x, name) metac__ ## m ## _## x ## _ ## name
#define METAC_MODULE_REQUEST(m, x, name) _METAC_MODULE_REQUEST(m, x, name)
#define _METAC_MODULE_RESPONSE(m, x, name) metac_ ## m ## _## x ## _ ## name
#define METAC_MODULE_RESPONSE(m, x, name) _METAC_MODULE_RESPONSE(m, x, name)


#endif